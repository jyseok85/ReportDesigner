@inherits ControlBase
@inject SelectedControlService SelectedControlService
@inject ControlResizeService ResizeService
@inject DragAndDropService DragService
@inject DesignerOptionService Options
@inject DesignerCSSService CSS
@inject IJSRuntime JsRuntime

<div class="component"
     tabindex="@Model.TabIndex"
     id = "@Model.Uid"
     @onpointerdown=@(e => OnPointerDown(e, "Control"))
     @ondblclick="@( (x) => OnDbClick(x))"
     @onkeydown="@( (x) => OnKeyDown(x))"
     style=@("transform:" + GetStyle("translate") + "position:absolute;" + GetStyle("width") + GetStyle("height") +
     GetStyle("border")+ GetStyle("background-color") + GetStyle("z-index") + "ime-mode:active;")>
     <CascadingValue Value="this">
        @* 드래그나 잠겨있거나 텍스트 입력할때 수정영역이 안보이게 하기 위해서 *@
        @if(DragService.Hidden && Model.Locked == false && this.Model.IsEditMode == false)
        {
            <ResizeArea @ref=ResizeArea Hidden=@(Model.Selected == true ? false : true )></ResizeArea>
        }
     </CascadingValue>
    <div class="overlay-text" hidden=@HiddenControl>
        visibility : hidden
     </div>

     <div class="component-text" style=@(OuterTextStyle)>
        <div @ref=innerText class ="component-text-inner" style=@(InnerTextStyle) >
            @Model.Text
         </div>
     </div>
     <RadzenTextArea @ref=textArea
        @ondrag:stopPropagation="true"
        @onpointerdown:stopPropagation="true"
        @onpointerup:stopPropagation="true"
        @onkeydown:stopPropagation="true"
        @onkeyup=OnEditorKeyUp
        class="w-100 component-text-input"
                    Style=@InputTextStyle hidden=@HiddenEditMode  
                    Change=@(args => OnChange(args, "TextArea with 3 rows and 30 columns")) />
</div>

@code {
    ElementReference innerText;
    public string OuterTextStyle
    {
        get
        {
            string style =
                GetStyle("align-items") +
                GetStyle("padding") + 
                GetStyle("justify-content");
            return style;
        }
    }
    public string InnerTextStyle
    {
        // //패딩 변경해야함.
        get
        {
            string style =
                           GetStyle("font-style") +
                           GetStyle("font-size") +
                           GetStyle("font-family") +
                           GetStyle("text-align") +
                           GetStyle("color") +
                           GetStyle("line-height") +
                           GetStyle("transform") +
                           GetStyle("transform-origin") + 
                           GetStyle("letter-spacing") + 
                           //GetStyle("overflow") +
                           GetStyle("overflow-text") +
                           //letter-spacing : 글자간의 간격 조절
                           //debug
                           "background-color:green;" 
                           ;
            return style;
        }
    }

    public string InputTextStyle
    {
        get
        {
            string style = GetStyle("padding") +
                           GetStyle("font-size") +
                           GetStyle("font-style") +
                           GetStyle("font-family") +
                           //포커스일때 기본컨트롤 스타일 삭제
                           "border:0px;"  +          
                           "box-shadow:none;" + 
                           //리사이즈 컨트롤 삭제
                           "resize:none;";      
            return style;
        }
    }

    public int Height => Model.Height;
    public int Width => Model.Width;
    private bool isDbClicked = false;
    ResizeArea ResizeArea;

    RadzenTextArea textArea;
    [Parameter]
    public ControlBase Base
    {
        set
        {
            this.Model = value.Model;
        }
    }

    public bool HiddenEditMode
    {
        get
        {
            if (this.Model.IsEditMode)
                return false;
            else
                return true;

        }
    }
    public bool HiddenControl
    {
        get
        {
            if (this.Model.Hidden)
                return false;
            else
                return true;

        }
    }

    void OnPointerDown(PointerEventArgs e, string value)
    {
        if (Options.EventStartObject != null)
            return;                  
        Options.EventStartObject = this;

        Logger.Instance.Write("");
        if(value == "EditArea")
        {
            return; 
        }

        if (Options.State == DesignerOptionService.ActionState.Resize)
        {
            Logger.Instance.Write("isDragAble - false");
            StateHasChanged();
        }
        else
        {
            StateHasChanged();
            SelectedControlService.OnPointerDown(e, this.Model, this);
            //ResizeArea.UpdateElementSize();

            //이거랑 부모쪽으로 이벤트 가는거랑 뭔 상관이냐?
            //드래그 오브젝트에서는 마우스 이벤트를 막지 않기 때문에 거기서 부모로 이동되는듯 하네.?? 근데 아니네??
            if (this.Model.Locked == false)
            {
                ResizeService.UpdateSize(this.Model.Width, this.Model.Height);

                DragService.StartDrag(Model.Uid, Model.X, Model.Y, Model.Width, Model.Height, e.ClientX, e.ClientY);
                //DragService.Hidden = false;
                Options.State = DesignerOptionService.ActionState.Drag;
            }
            Logger.Instance.Write("isDragAble = true;");
        }
    }

    public string GetStyle(string type)
    {
        var style= CSS.GetModelStyle(type, this.Model);
        return style;
    }

    private bool isCanceled = false;
    private string preText = "";
    public async Task OnDbClick(MouseEventArgs args)
    {
        Logger.Instance.Write("OnDoubleClick");
        if (this.Model.Locked is true)
        {
            Logger.Instance.Write("Locked!!");
            return;
        }

        this.Model.IsEditMode = true;
        this.preText = this.Model.Text;
        this.isCanceled = false;
        Options.State = DesignerOptionService.ActionState.Edit;
        DragService.End();

        while (this.textArea == null)
            await Task.Delay(10);

        this.textArea.Value = this.Model.Text;
        await this.textArea.Element.FocusAsync();
        await this.textArea.Element.FocusAsync();
        this.StateHasChanged();
    }

    private async Task OnEditorKeyUp(KeyboardEventArgs e)
    {
        //기능정의 : esc키를 누르면 입력을 취소한다.
        //기능정의 : ctrl + enter키를 누르면 입력을 완료한다.

        if (e.Key.Contains("Escape"))
        {
            Logger.Instance.Write("Editor - Escape");

            this.Model.IsEditMode = false;

            this.isCanceled = true;
            Options.State = DesignerOptionService.ActionState.None;
            this.StateHasChanged();

        }
        if (e.CtrlKey && e.Key == "Enter")
        {
            this.Model.IsEditMode = false;
            Options.State = DesignerOptionService.ActionState.None;
            this.StateHasChanged();
        }
    }
    private async Task OnKeyDown(KeyboardEventArgs e)
    {

    }
    async void OnChange(string value, string name)
    {        
        Logger.Instance.Write(value);
        if(isCanceled == true)
            this.Model.Text = preText;
        else
            this.Model.Text = value;


        StateHasChanged();
    }

    /// <summary>
    /// 내부 텍스트 사이즈 변경 이벤트 등록
    /// </summary>
    /// <param name="firstRender"></param>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JsRuntime.InvokeAsync<object>("RegisterInnerTextResizeCallback", Model.Uid);
        }
    }
  
    //todo : 컨트롤 사이즈를 변경할때 밴드 영역을 벗어나서 이벤트 끊어질때 먹통됨.


    //현재 컨트롤의 사이즈와 component-text-inner 자식 컨트롤의 크기를 비교하는 함수

  


}
